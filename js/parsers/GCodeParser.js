/**
 * GCodeParser
 * Main G-code parser with slicer detection and delegation to format-specific parsers
 */

class GCodeParser {
  constructor() {
    this.parsers = {};
  }

  /**
   * Register a slicer-specific parser
   * @param {string} name - Slicer name
   * @param {Object} parser - Parser instance
   */
  registerParser(name, parser) {
    this.parsers[name] = parser;
  }

  /**
   * Parse G-code file content
   * @param {string} content - Raw G-code file content
   * @returns {Object} Parsed data
   */
  parse(content) {
    // Detect slicer type
    const slicerType = this.detectSlicer(content);

    // Use appropriate parser if available
    if (slicerType && this.parsers[slicerType]) {
      const result = this.parsers[slicerType].parse(content);
      return {
        success: true,
        slicerType,
        slicerName: this.getSlicerDisplayName(slicerType),
        ...result,
      };
    }

    // Fallback to generic parsing
    const result = this.genericParse(content);
    return {
      success: true,
      slicerType: 'unknown',
      slicerName: 'Unknown Slicer',
      ...result,
    };
  }

  /**
   * Detect which slicer generated the G-code
   * @param {string} content - G-code content
   * @returns {string|null} Slicer type identifier
   */
  detectSlicer(content) {
    // Check first 100 lines for slicer signatures
    const headerLines = content.split('\n').slice(0, 100).join('\n').toLowerCase();
    // Also check last 200 lines (PrusaSlicer puts info at end)
    const lines = content.split('\n');
    const tailLines = lines.slice(-200).join('\n').toLowerCase();
    const allSample = headerLines + '\n' + tailLines;

    // PrusaSlicer / OrcaSlicer / BambuStudio
    if (allSample.includes('prusaslicer') ||
        allSample.includes('generated by prusa')) {
      return 'prusaslicer';
    }

    // OrcaSlicer (check before generic PrusaSlicer since it's a fork)
    if (allSample.includes('orcaslicer')) {
      return 'orcaslicer';
    }

    // BambuStudio
    if (allSample.includes('bambustudio') || allSample.includes('bambu studio')) {
      return 'bambustudio';
    }

    // SuperSlicer
    if (allSample.includes('superslicer')) {
      return 'superslicer';
    }

    // Cura
    if (allSample.includes('cura') ||
        allSample.includes(';flavor:') ||
        allSample.includes('cura_profile_string')) {
      return 'cura';
    }

    // Simplify3D
    if (allSample.includes('simplify3d') ||
        allSample.includes('; g-code generated by simplify3d')) {
      return 'simplify3d';
    }

    // IdeaMaker
    if (allSample.includes('ideamaker')) {
      return 'ideamaker';
    }

    // Slic3r (original)
    if (allSample.includes('slic3r') &&
        !allSample.includes('prusaslicer') &&
        !allSample.includes('superslicer')) {
      return 'slic3r';
    }

    return null;
  }

  /**
   * Get display name for slicer type
   * @param {string} slicerType - Slicer type identifier
   * @returns {string} Display name
   */
  getSlicerDisplayName(slicerType) {
    const names = {
      'prusaslicer': 'PrusaSlicer',
      'superslicer': 'SuperSlicer',
      'orcaslicer': 'OrcaSlicer',
      'bambustudio': 'Bambu Studio',
      'cura': 'Ultimaker Cura',
      'simplify3d': 'Simplify3D',
      'ideamaker': 'IdeaMaker',
      'slic3r': 'Slic3r',
      'unknown': 'Unknown Slicer',
    };
    return names[slicerType] || slicerType;
  }

  /**
   * Generic fallback parser for unknown slicers
   * @param {string} content - G-code content
   * @returns {Object} Parsed data
   */
  genericParse(content) {
    const result = {
      printTimeMinutes: null,
      filamentUsedMm: null,
      filamentUsedGrams: null,
      filamentUsedMeters: null,
      layerHeight: null,
      layerCount: null,
      nozzleDiameter: null,
      filamentDiameter: null,
      filamentDensity: null,
      filamentType: null,
    };

    const lines = content.split('\n');

    // Common patterns across slicers
    const patterns = {
      // Time in seconds
      timeSeconds: /;\s*(?:time|print[_\s]*time|estimated[_\s]*time)[:\s=]+(\d+)\s*(?:s|sec|seconds)?$/i,
      // Time formatted (1h 30m 45s or similar)
      timeFormatted: /;\s*(?:time|print[_\s]*time|estimated[_\s]*time)[:\s=]+(?:(\d+)\s*d(?:ays?)?\s*)?(?:(\d+)\s*h(?:ours?)?\s*)?(?:(\d+)\s*m(?:in(?:utes?)?)?\s*)?(?:(\d+)\s*s(?:ec(?:onds?)?)?)?/i,
      // Filament in mm
      filamentMm: /;\s*filament[_\s]*(?:used|length)?\s*\[?mm\]?[:\s=]+([\d.]+)/i,
      // Filament in meters
      filamentM: /;\s*filament[_\s]*(?:used|length)?[:\s=]+([\d.]+)\s*m(?:eters?)?(?:\s|$)/i,
      // Filament in grams
      filamentG: /;\s*filament[_\s]*(?:used|weight)?\s*\[?g(?:rams?)?\]?[:\s=]+([\d.]+)/i,
      // Filament in cm3
      filamentCm3: /;\s*filament[_\s]*(?:used|volume)?\s*\[?cm3\]?[:\s=]+([\d.]+)/i,
      // Layer height
      layerHeight: /;\s*layer[_\s]*height[:\s=]+([\d.]+)/i,
      // Layer count
      layerCount: /;\s*(?:layer[_\s]*count|total[_\s]*layers)[:\s=]+(\d+)/i,
      // Nozzle diameter
      nozzleDiameter: /;\s*nozzle[_\s]*diameter[:\s=]+([\d.]+)/i,
      // Filament diameter
      filamentDiameter: /;\s*filament[_\s]*diameter[:\s=]+([\d.]+)/i,
      // Filament density
      filamentDensity: /;\s*filament[_\s]*density[:\s=]+([\d.]+)/i,
      // Filament type
      filamentType: /;\s*filament[_\s]*type[:\s=]+(\w+)/i,
    };

    // Scan all lines
    for (const line of lines) {
      // Time in seconds
      let match = line.match(patterns.timeSeconds);
      if (match && !result.printTimeMinutes) {
        result.printTimeMinutes = parseInt(match[1]) / 60;
        continue;
      }

      // Time formatted
      match = line.match(patterns.timeFormatted);
      if (match && !result.printTimeMinutes) {
        const days = parseInt(match[1]) || 0;
        const hours = parseInt(match[2]) || 0;
        const minutes = parseInt(match[3]) || 0;
        const seconds = parseInt(match[4]) || 0;
        const totalMinutes = (days * 24 * 60) + (hours * 60) + minutes + (seconds / 60);
        if (totalMinutes > 0) {
          result.printTimeMinutes = totalMinutes;
        }
        continue;
      }

      // Filament mm
      match = line.match(patterns.filamentMm);
      if (match && !result.filamentUsedMm) {
        result.filamentUsedMm = parseFloat(match[1]);
        continue;
      }

      // Filament meters
      match = line.match(patterns.filamentM);
      if (match && !result.filamentUsedMeters) {
        result.filamentUsedMeters = parseFloat(match[1]);
        if (!result.filamentUsedMm) {
          result.filamentUsedMm = result.filamentUsedMeters * 1000;
        }
        continue;
      }

      // Filament grams
      match = line.match(patterns.filamentG);
      if (match && !result.filamentUsedGrams) {
        result.filamentUsedGrams = parseFloat(match[1]);
        continue;
      }

      // Filament cm3
      match = line.match(patterns.filamentCm3);
      if (match && !result.filamentUsedCm3) {
        result.filamentUsedCm3 = parseFloat(match[1]);
        continue;
      }

      // Layer height
      match = line.match(patterns.layerHeight);
      if (match && !result.layerHeight) {
        result.layerHeight = parseFloat(match[1]);
        continue;
      }

      // Layer count
      match = line.match(patterns.layerCount);
      if (match && !result.layerCount) {
        result.layerCount = parseInt(match[1]);
        continue;
      }

      // Nozzle diameter
      match = line.match(patterns.nozzleDiameter);
      if (match && !result.nozzleDiameter) {
        result.nozzleDiameter = parseFloat(match[1]);
        continue;
      }

      // Filament diameter
      match = line.match(patterns.filamentDiameter);
      if (match && !result.filamentDiameter) {
        result.filamentDiameter = parseFloat(match[1]);
        continue;
      }

      // Filament density
      match = line.match(patterns.filamentDensity);
      if (match && !result.filamentDensity) {
        result.filamentDensity = parseFloat(match[1]);
        continue;
      }

      // Filament type
      match = line.match(patterns.filamentType);
      if (match && !result.filamentType) {
        result.filamentType = match[1].toUpperCase();
        continue;
      }
    }

    // Calculate grams from other values if missing
    this.calculateMissingValues(result);

    return result;
  }

  /**
   * Calculate missing values from available data
   * @param {Object} result - Parsed result object (modified in place)
   */
  calculateMissingValues(result) {
    const diameter = result.filamentDiameter || 1.75;
    const density = result.filamentDensity || 1.24; // PLA default

    // Calculate grams from volume (cm3)
    if (!result.filamentUsedGrams && result.filamentUsedCm3) {
      result.filamentUsedGrams = result.filamentUsedCm3 * density;
    }

    // Calculate grams from length (mm)
    if (!result.filamentUsedGrams && result.filamentUsedMm) {
      const radiusCm = (diameter / 2) / 10;
      const lengthCm = result.filamentUsedMm / 10;
      const volumeCm3 = Math.PI * Math.pow(radiusCm, 2) * lengthCm;
      result.filamentUsedGrams = volumeCm3 * density;
    }

    // Calculate meters from mm
    if (!result.filamentUsedMeters && result.filamentUsedMm) {
      result.filamentUsedMeters = result.filamentUsedMm / 1000;
    }

    // Round values
    if (result.filamentUsedGrams) {
      result.filamentUsedGrams = Math.round(result.filamentUsedGrams * 100) / 100;
    }
    if (result.printTimeMinutes) {
      result.printTimeMinutes = Math.round(result.printTimeMinutes * 10) / 10;
    }
  }
}

// Create singleton instance
const gcodeParser = new GCodeParser();
